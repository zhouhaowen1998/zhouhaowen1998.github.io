<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leon.blog</title>
  
  <subtitle>生命不息 脱发不止</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhouhaowen1998.github.io/"/>
  <updated>2020-02-28T14:46:38.175Z</updated>
  <id>http://zhouhaowen1998.github.io/</id>
  
  <author>
    <name>周浩文</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用的消息中间件入门总结</title>
    <link href="http://zhouhaowen1998.github.io/2020/02/28/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://zhouhaowen1998.github.io/2020/02/28/常用的消息中间件入门总结/</id>
    <published>2020-02-28T13:26:41.000Z</published>
    <updated>2020-02-28T14:46:38.175Z</updated>
    
    <content type="html"><![CDATA[<p>常用的一些消息中间件的入门总结</p><p>MQ主要核心功能是用来处理解耦、异步 、削峰。</p><p>而添加MQ以后也会出现一些缺点：<br>    系统可用性降低 ：当MQ出现问题的时候，相关联系统同时也无法正常接收消息<br>    系统复杂性提高 ：消息重复消费、消息丢失、消息传递的顺序性被打乱<br>    一致性问题      ：数据在传递到MQ后，可能没有发出（或者下流的系统没有接收到）导致数据不一致。 </p><p>通过网上一些系统的学习和入门博客，目前大概主流的消息中间件有Activemq rabbitmq rocketmq 以及kafka。<br>下面就是对这些中间件的相关特点进行总结比较<br>ps：这里只是单纯总结，没有实际代码，如果完全没有使用过这些东西，可以去百度搜索入门教程看看。</p><p>下面是对Activemq rabbitmq rocketmq 以及kafka之前的对比</p><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">ActiveMQ</th><th style="text-align:left">RabbitMQ</th><th style="text-align:left">RocketMq</th><th style="text-align:left">Kafka</th></tr></thead><tbody><tr><td style="text-align:left">单机吞吐量</td><td style="text-align:left">万级，<br>吞吐量比RocketMQ 、<br> Kafka低了一个数量级</td><td style="text-align:left">万级，<br>吞吐量比RocketMQ、<br> Kafka低了一个数量级</td><td style="text-align:left">十万级，<br>也是一个可以支撑高吞吐的MQ</td><td style="text-align:left">十万级，<br>kafka最大优点就是吞吐量高<br>一般配合大数据类系统机型数据计算和日志采集</td></tr><tr><td style="text-align:left">Topic 数量对吞<br>吐量的影响</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">可以到达几百个，<br>几千个的级别的时候吞吐量时<br>会有较小幅度的下降<br>在同等机器下，<br>可一支撑大量topic</td><td style="text-align:left">从几十个倒带几百个的时候，<br>吞吐量会大幅度下降</td></tr><tr><td style="text-align:left">时效性</td><td style="text-align:left">ms级</td><td style="text-align:left">微秒级，<br>这是最大特点</td><td style="text-align:left">ms级</td><td style="text-align:left">ms级以内</td></tr><tr><td style="text-align:left">可用性</td><td style="text-align:left">高,<br>基于主从架构实现高可用性</td><td style="text-align:left">高,<br>基于主从架构实现高可用性</td><td style="text-align:left">非常高，<br>分布式架构</td><td style="text-align:left">非常高，kafka是分布式的，<br>一个数据多个副本，<br>少数极其宕机，<br>不会丢失数据，<br>不会导致不可用</td></tr><tr><td style="text-align:left">消息可靠性</td><td style="text-align:left">有较低概率丢失数据</td><td style="text-align:left">一般不丢</td><td style="text-align:left">参数优化可以做到0丢失</td><td style="text-align:left">参数优化可以做到0丢失</td></tr><tr><td style="text-align:left">功能支持</td><td style="text-align:left">MQ领域的功能极其完备</td><td style="text-align:left">基于erlang开发，<br>并发能力强，<br>性能好，<br>延时低</td><td style="text-align:left">比较完善，<br>分布式且扩展性好</td><td style="text-align:left">功能较为简单，<br>主要支持简单的MQ功能，<br>在大数据领域的实时计算、<br>日志采集被大规模使用<br>且是事实上的标准</td></tr><tr><td style="text-align:left">优劣势总结</td><td style="text-align:left">技术成熟，功能强大，<br>大量公司和项目都有应用。<br>偶尔会出现较低概率丢失消息。<br>社区现在对5.X维护越来越少，<br>主要是基于解耦和异步来使用，<br>一般大规模吞吐的场景中很少使用</td><td style="text-align:left">Erlang语言开发，性能好，<br>延时低而且开源提供管理界面很好，<br>社区相对比较活跃，<br>几乎每个月都发布几个版本<br>问题也显而易见的，吞吐量比较低，<br>因为他们做的实现机制比较重，<br>Erlang开发在国内没有几个公司<br>很少有实力做源码级别的研究，<br>基本就只能依赖开源社区的维护和修复BUG</td><td style="text-align:left">接口简单应用，<br>日处理量可以上百亿之多，<br>可以做到大规模吞吐，<br>性能非常好分布式扩展也很方便，<br>社区比较比较活跃，<br>可靠性和可用性都是ok的，<br>还能支持大规模的topic数量，<br>支持复杂的MQ业务场景<br>由阿里用JAVA开发，能够自己阅读和掌控<br>但是接口不是按照标椎的JMS规范走的，<br>有些系统迁移需要修改大量代码</td><td style="text-align:left">提供超高的吞吐量和ms级别的延迟，<br>极高的可用性以及可靠性<br>而且分布式可以任意拓展<br>同时kafka最好支撑较少的topic数量<br>保证超高吞吐量<br>缺点就是消息可能重复消费，<br>对数据准确性会造成轻微影响，<br>但以大数据领域中这点影响可以忽略<br>这个特性天然用大数据实时计算和<br>日志收集</td></tr></tbody></table><p>综上所述<br>一般业务引入MQ 大家都用ActiveMQ但是现在现在不建议推荐。<br>后来大家开始用RabbitMQ比较稳定的支持，活跃度也行，中小型公司使用不错。<br>RocketMQ也不错但是要考虑社区突然黄掉的风险，公司对自己技术实力有绝对自信的 能够对RocketMQ有一定研发和掌控的 推荐用RocketMQ。<br>所以中小公司技术实力一般的,技术挑战不高的用RabbitMQ是不错选择。<br>大型公司，基础架构研发实力强的话，用RocketMQ是很好选择。<br>如果是大数据领域的实时计算、日志采集的话,用kafka是业内标准！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常用的一些消息中间件的入门总结&lt;/p&gt;
&lt;p&gt;MQ主要核心功能是用来处理解耦、异步 、削峰。&lt;/p&gt;
&lt;p&gt;而添加MQ以后也会出现一些缺点：&lt;br&gt;    系统可用性降低 ：当MQ出现问题的时候，相关联系统同时也无法正常接收消息&lt;br&gt;    系统复杂性提高 ：消息重复消费
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java中的内存泄露和溢出</title>
    <link href="http://zhouhaowen1998.github.io/2020/02/27/Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%92%8C%E6%BA%A2%E5%87%BA/"/>
    <id>http://zhouhaowen1998.github.io/2020/02/27/Java中的内存泄露和溢出/</id>
    <published>2020-02-27T12:36:21.000Z</published>
    <updated>2020-02-27T12:41:37.330Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的内存泄露和溢出</p><p>内存溢出：（Out Of Memory—OOM）<br>系统已经不能再分配出你所需要的空间，比如你需要100M的空间，系统只剩90M了，这就叫内存溢出<br>例子：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。说白了就是我承受不了那么多，那我就报错，</p><a id="more"></a><p>内存泄漏：  (Memory Leak)<br>Java有垃圾收集器帮助实现内存自动管理，虽然GC有效的处理了大部分内存，但是并不能完全保证内存的不泄露。</p><p>强引用所指向的对象不会被回收，可能导致内存泄漏，虚拟机宁愿抛出OOM也不会去回收他指向的对象<br>意思就是你用资源的时候为他开辟了一段空间，当你用完时忘记释放资源了，这时内存还被占用着，一次没关系，但是内存泄漏次数多了就会导致内存溢出<br>例子：你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。</p><p>2.以发生的方式来分类，内存泄漏可以分为4类： </p><ol><li>常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。 </li><li>偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。 </li><li>一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。 </li><li>隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。<br>从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到</li></ol><p>内存溢出的原因及解决方法：</p><ol><li>内存溢出原因：<br>1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据；<br>2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；<br>3.代码中存在死循环或循环产生过多重复的对象实体；<br>4.使用的第三方软件中的BUG；<br>5.启动参数内存值设定的过小</li><li>内存溢出的原因及解决方法：<br>1.修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)<br>2.检查错误日志，查看“OutOfMemory”错误前是否有其 它异常或错误。<br>3.对代码进行走查和分析，找出可能发生内存溢出的位置。<br>4.使用内存查看工具动态查看内存使用情况　　</li></ol><p>代码分析找出可能发生内存溢出的位置， 可能出现的几种情况：<br>1、检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。<br>2、检查代码中是否有死循环或递归调用。<br>3、检查是否有大循环重复产生新对象实体。<br>4、检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java中的内存泄露和溢出&lt;/p&gt;
&lt;p&gt;内存溢出：（Out Of Memory—OOM）&lt;br&gt;系统已经不能再分配出你所需要的空间，比如你需要100M的空间，系统只剩90M了，这就叫内存溢出&lt;br&gt;例子：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。说白了就是我承受不了那么多，那我就报错，&lt;/p&gt;
    
    </summary>
    
      <category term="默认分类" scheme="http://zhouhaowen1998.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="JAVA基础" scheme="http://zhouhaowen1998.github.io/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java中的GC回收</title>
    <link href="http://zhouhaowen1998.github.io/2020/02/26/java%E4%B8%AD%E7%9A%84GC%E5%9B%9E%E6%94%B6/"/>
    <id>http://zhouhaowen1998.github.io/2020/02/26/java中的GC回收/</id>
    <published>2020-02-26T14:20:35.000Z</published>
    <updated>2020-02-26T15:22:36.545Z</updated>
    
    <content type="html"><![CDATA[<p>最近准备求职，所以把JAVA一些基础部分从头捞出来复习，所以就大概的网上搜上整理了一些资料。<br>相对于C和C++ Java中的有自带的GC(垃圾回收)机制，不用每次自己手动去调用函数去释放空间。</p><a id="more"></a><p>java中GC回收机制<br>GC（Garbage collection）是Java垃圾回收机制，用于将内存中无用对象进行回收处理。</p><p>基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停</p><p>哪些内存需要回收？<br>Java堆和方法区</p><p>运行时数据区的程序计数器、虚拟机栈、本地方法栈都随线程的产生而产生、消灭而消灭。每一个栈帧分配多少内存编译时可知，因此这些区域不需要回收。此外，在堆中，尤其新生代，一次垃圾回收可以回收70%-95%的空间，而方法区的效率远低于此。</p><p>怎么回收？<br>通过垃圾处理器<br>    1.对新生代的对象的收集称为minor GC；<br>    2.对旧生代的对象的收集称为Full GC；<br>    3.程序中主动调用System.gc()强制执行的GC为Full GC。</p><p>何时回收？<br>不同的对象引用类型， GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型：<br>    1.强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收）<br>    2.软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）<br>    3.弱引用：在GC时一定会被GC回收<br>    4.虚引用：由于虚引用只是用来得知对象是否被GC</p><p>垃圾收集算法<br>最基础的算法：<br>分标记和清除两个阶段：首先标记出所需要回收的对象，在标记完成后统一回收所有被标记的对象。<br>不足：效率问题，标记和清除过程都效率不高；空间问题，标记清除之后会产生大量不连续的内存碎片（类似于我们电脑的磁盘碎片），空间碎片太多导致需要分配大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。</p><p>复制算法：<br>为了解决效率问题，出现了“复制”算法，他将可用内存按容量划分为大小相等的两块，每次只需要使用其中一块。当一块内存用完了，将还存活的对象复制到另一块上面，然后再把刚刚用完的内存空间一次清理掉。这样就解决了内存碎片问题，但是代价就是可以用内容就缩小为原来的一半。</p><p>标记-整理算法：<br>复制算法在对象存活率较高时就会进行频繁的复制操作，效率将降低。因此又有了标记-整理算法，标记过程同标记-清除算法，但是在后续步骤不是直接对对象进行清理，而是让所有存活的对象都向一侧移动，然后直接清理掉端边界以外的内存。</p><p>分代收集算法：<br>当前商业虚拟机的GC都是采用分代收集算法，这种算法并没有什么新的思想，而是根据对象存活周期的不同将堆分为：新生代和老年代，方法区称为永久代（在新的版本中已经将永久代废弃，引入了元空间的概念，永久代使用的是JVM内存而元空间直接使用物理内存）。这样就可以根据各个年代的特点采用不同的收集算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近准备求职，所以把JAVA一些基础部分从头捞出来复习，所以就大概的网上搜上整理了一些资料。&lt;br&gt;相对于C和C++ Java中的有自带的GC(垃圾回收)机制，不用每次自己手动去调用函数去释放空间。&lt;/p&gt;
    
    </summary>
    
      <category term="默认分类" scheme="http://zhouhaowen1998.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="JAVA基础" scheme="http://zhouhaowen1998.github.io/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>关于此博客</title>
    <link href="http://zhouhaowen1998.github.io/2020/02/25/%E5%85%B3%E4%BA%8E%E6%AD%A4%E5%8D%9A%E5%AE%A2/"/>
    <id>http://zhouhaowen1998.github.io/2020/02/25/关于此博客/</id>
    <published>2020-02-25T12:57:25.000Z</published>
    <updated>2020-02-25T13:06:15.346Z</updated>
    
    <content type="html"><![CDATA[<p>空闲之余利用nexo和github搭建出来这个博客，没有想象中的那么难，但也还有许多地方需要慢慢探索。今后这个博客就用来记录自己的学习过程以及学习中对技术知识点的理解和分析，以便后期对知识的复习和巩固，同时也希望这个微博中的文章能够给来过的朋友带来一些帮助和便利!</p>]]></content>
    
    <summary type="html">
    
      闲下来随手创建的一个博客
    
    </summary>
    
      <category term="默认分类" scheme="http://zhouhaowen1998.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="声明，规划" scheme="http://zhouhaowen1998.github.io/tags/%E5%A3%B0%E6%98%8E%EF%BC%8C%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
