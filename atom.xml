<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leon.blog</title>
  
  <subtitle>生命不息 脱发不止</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhouhaowen1998.github.io/"/>
  <updated>2020-02-26T14:54:34.713Z</updated>
  <id>http://zhouhaowen1998.github.io/</id>
  
  <author>
    <name>周浩文</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java中的GC回收</title>
    <link href="http://zhouhaowen1998.github.io/2020/02/26/java%E4%B8%AD%E7%9A%84GC%E5%9B%9E%E6%94%B6/"/>
    <id>http://zhouhaowen1998.github.io/2020/02/26/java中的GC回收/</id>
    <published>2020-02-26T14:20:35.000Z</published>
    <updated>2020-02-26T14:54:34.713Z</updated>
    
    <content type="html"><![CDATA[<p>最近准备求职，所以把JAVA一些基础部分从头捞出来复习，所以就大概的网上搜上整理了一些资料。<br>相对于C和C++ Java中的有自带的GC(垃圾回收)机制，不用每次自己手动去调用函数去释放空间。<br><a id="more"></a></p><ol><li>java中GC回收机制<br>GC（Garbage collection）是Java垃圾回收机制，用于将内存中无用对象进行回收处理。<br>基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停<br>哪些内存需要回收？<br>Java堆和方法区<br>运行时数据区的程序计数器、虚拟机栈、本地方法栈都随线程的产生而产生、消灭而消灭。每一个栈帧分配多少内存编译时可知，因此这些区域不需要回收。此外，在堆中，尤其新生代，一次垃圾回收可以回收70%-95%的空间，而方法区的效率远低于此。<br>怎么回收？<br>通过垃圾处理器<br>（1）对新生代的对象的收集称为minor GC；<br>（2）对旧生代的对象的收集称为Full GC；<br>（3）程序中主动调用System.gc()强制执行的GC为Full GC。</li></ol><p>何时回收？<br>不同的对象引用类型， GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型：<br>（1）强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收）<br>（2）软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）<br>（3）弱引用：在GC时一定会被GC回收<br>（4）虚引用：由于虚引用只是用来得知对象是否被GC</p><p>垃圾收集算法<br>最基础的算法：<br>分标记和清除两个阶段：首先标记出所需要回收的对象，在标记完成后统一回收所有被标记的对象。<br>不足：效率问题，标记和清除过程都效率不高；空间问题，标记清除之后会产生大量不连续的内存碎片（类似于我们电脑的磁盘碎片），空间碎片太多导致需要分配大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。<br>复制算法：<br>为了解决效率问题，出现了“复制”算法，他将可用内存按容量划分为大小相等的两块，每次只需要使用其中一块。当一块内存用完了，将还存活的对象复制到另一块上面，然后再把刚刚用完的内存空间一次清理掉。这样就解决了内存碎片问题，但是代价就是可以用内容就缩小为原来的一半。<br>标记-整理算法：<br>复制算法在对象存活率较高时就会进行频繁的复制操作，效率将降低。因此又有了标记-整理算法，标记过程同标记-清除算法，但是在后续步骤不是直接对对象进行清理，而是让所有存活的对象都向一侧移动，然后直接清理掉端边界以外的内存。<br>分代收集算法：当前商业虚拟机的GC都是采用分代收集算法，这种算法并没有什么新的思想，而是根据对象存活周期的不同将堆分为：新生代和老年代，方法区称为永久代（在新的版本中已经将永久代废弃，引入了元空间的概念，永久代使用的是JVM内存而元空间直接使用物理内存）。这样就可以根据各个年代的特点采用不同的收集算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近准备求职，所以把JAVA一些基础部分从头捞出来复习，所以就大概的网上搜上整理了一些资料。&lt;br&gt;相对于C和C++ Java中的有自带的GC(垃圾回收)机制，不用每次自己手动去调用函数去释放空间。&lt;br&gt;
    
    </summary>
    
      <category term="默认分类" scheme="http://zhouhaowen1998.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="JAVA基础" scheme="http://zhouhaowen1998.github.io/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>关于此博客</title>
    <link href="http://zhouhaowen1998.github.io/2020/02/25/%E5%85%B3%E4%BA%8E%E6%AD%A4%E5%8D%9A%E5%AE%A2/"/>
    <id>http://zhouhaowen1998.github.io/2020/02/25/关于此博客/</id>
    <published>2020-02-25T12:57:25.000Z</published>
    <updated>2020-02-25T13:06:15.346Z</updated>
    
    <content type="html"><![CDATA[<p>空闲之余利用nexo和github搭建出来这个博客，没有想象中的那么难，但也还有许多地方需要慢慢探索。今后这个博客就用来记录自己的学习过程以及学习中对技术知识点的理解和分析，以便后期对知识的复习和巩固，同时也希望这个微博中的文章能够给来过的朋友带来一些帮助和便利!</p>]]></content>
    
    <summary type="html">
    
      闲下来随手创建的一个博客
    
    </summary>
    
      <category term="默认分类" scheme="http://zhouhaowen1998.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="声明，规划" scheme="http://zhouhaowen1998.github.io/tags/%E5%A3%B0%E6%98%8E%EF%BC%8C%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
